<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Raíces Numéricas</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Configuración personalizada de Tailwind */
        :root {
            --primary-color: #3b82f6; /* blue-500 */
            --secondary-color: #10b981; /* emerald-500 */
            --bg-color: #f9fafb; /* gray-50 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
        }
        .tab-active {
            border-bottom: 4px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: 600;
        }
        .input-box {
            border: 2px solid #e5e7eb;
            transition: all 0.3s;
        }
        .input-box:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .result-table th {
            background-color: #f3f4f6;
        }
        .button-primary {
            background-color: var(--primary-color);
            transition: background-color 0.2s;
        }
        .button-primary:hover {
            background-color: #2563eb; /* blue-600 */
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-4xl mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10">

        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">
            Solucionador de Raíces Numéricas
        </h1>

        <!-- SECCIÓN DE ENTRADA COMÚN -->
        <div class="mb-8 p-4 bg-gray-50 rounded-lg border">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Ecuación y Parámetros Iniciales</h2>
            
            <div class="mb-4">
                <label for="equation" class="block text-sm font-medium text-gray-700 mb-1">
                    Función f(x) (donde f(x)=0)
                </label>
                <input type="text" id="equation" value="x**3 - Math.exp(0.8*x) - 20"
                       class="w-full p-3 input-box rounded-lg text-gray-900 placeholder-gray-400"
                       placeholder="Ej: x**3 - Math.exp(0.8*x) - 20">
                <p class="mt-1 text-xs text-gray-500">
                    Use ** para potencia (x**3), Math.exp(), Math.sin(), Math.cos(), Math.log() (ln).
                </p>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4">
                <div>
                    <label for="tolerance" class="block text-sm font-medium text-gray-700 mb-1">Tolerancia (Error)</label>
                    <input type="number" id="tolerance" value="0.0001" step="any"
                           class="w-full p-3 input-box rounded-lg text-gray-900">
                </div>
                <div>
                    <label for="maxIterations" class="block text-sm font-medium text-gray-700 mb-1">Máx. Iteraciones</label>
                    <input type="number" id="maxIterations" value="50"
                           class="w-full p-3 input-box rounded-lg text-gray-900">
                </div>
                <div>
                    <label for="hValue" class="block text-sm font-medium text-gray-700 mb-1">h para Derivada Numérica</label>
                    <input type="number" id="hValue" value="0.000001" step="any"
                           class="w-full p-3 input-box rounded-lg text-gray-900">
                </div>
            </div>

            <!-- Parámetros específicos para Bisección y Secante/Newton -->
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                <div>
                    <label for="aValue" class="block text-sm font-medium text-gray-700 mb-1">Límite Inferior (a)</label>
                    <input type="number" id="aValue" value="3" step="any"
                           class="w-full p-3 input-box rounded-lg text-gray-900"
                           placeholder="Para Bisección">
                </div>
                <div>
                    <label for="bValue" class="block text-sm font-medium text-gray-700 mb-1">Límite Superior (b)</label>
                    <input type="number" id="bValue" value="4" step="any"
                           class="w-full p-3 input-box rounded-lg text-gray-900"
                           placeholder="Para Bisección/Secante (x1)">
                </div>
                <div>
                    <label for="x0Value" class="block text-sm font-medium text-gray-700 mb-1">Estimación Inicial (x0)</label>
                    <input type="number" id="x0Value" value="3.5" step="any"
                           class="w-full p-3 input-box rounded-lg text-gray-900"
                           placeholder="Para Newton/Secante (x0)">
                </div>
            </div>
        </div>

        <!-- SECCIÓN DE NAVEGACIÓN DE MÉTODOS -->
        <div class="flex border-b border-gray-200 mb-6 space-x-4 overflow-x-auto">
            <button id="tab-biseccion" class="p-3 text-gray-600 hover:text-blue-500 whitespace-nowrap tab-active" onclick="switchTab('biseccion')">
                Método de Bisección
            </button>
            <button id="tab-newton" class="p-3 text-gray-600 hover:text-blue-500 whitespace-nowrap" onclick="switchTab('newton')">
                Método de Newton-Raphson
            </button>
            <button id="tab-secante" class="p-3 text-gray-600 hover:text-blue-500 whitespace-nowrap" onclick="switchTab('secante')">
                Método de la Secante
            </button>
            <button id="tab-exacta" class="p-3 text-gray-600 hover:text-blue-500 whitespace-nowrap" onclick="switchTab('exacta')">
                Comprobación (f(raíz))
            </button>
        </div>

        <!-- CONTENEDOR DE RESULTADOS -->
        <div id="method-container" class="space-y-6">

            <!-- Pestaña de Bisección -->
            <div id="content-biseccion" class="method-content">
                <button class="w-full button-primary text-white p-3 rounded-lg font-semibold shadow-md hover:shadow-lg transition-shadow" onclick="runSolver('biseccion')">
                    Resolver por Bisección
                </button>
                <div class="mt-4 p-4 bg-yellow-100 text-yellow-800 rounded-lg text-sm" role="alert">
                    <span class="font-medium">Importante:</span> El método de Bisección requiere que f(a) y f(b) tengan signos opuestos.
                </div>
                <div id="biseccion-result" class="mt-6"></div>
            </div>

            <!-- Pestaña de Newton-Raphson -->
            <div id="content-newton" class="method-content hidden">
                <button class="w-full button-primary text-white p-3 rounded-lg font-semibold shadow-md hover:shadow-lg transition-shadow" onclick="runSolver('newton')">
                    Resolver por Newton-Raphson
                </button>
                <div class="mt-4 p-4 bg-yellow-100 text-yellow-800 rounded-lg text-sm" role="alert">
                    <span class="font-medium">Importante:</span> Este método usa derivada numérica. Requiere una buena estimación inicial (x0).
                </div>
                <div id="newton-result" class="mt-6"></div>
            </div>

            <!-- Pestaña de la Secante -->
            <div id="content-secante" class="method-content hidden">
                <button class="w-full button-primary text-white p-3 rounded-lg font-semibold shadow-md hover:shadow-lg transition-shadow" onclick="runSolver('secante')">
                    Resolver por la Secante
                </button>
                <div class="mt-4 p-4 bg-yellow-100 text-yellow-800 rounded-lg text-sm" role="alert">
                    <span class="font-medium">Importante:</span> El método de la Secante requiere dos puntos iniciales (x0 y x1).
                </div>
                <div id="secante-result" class="mt-6"></div>
            </div>

            <!-- Pestaña de Comprobación -->
            <div id="content-exacta" class="method-content hidden">
                <div class="p-6 bg-gray-100 rounded-lg">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Comprobación de la Solución Numérica</h3>
                    <p class="text-gray-600 mb-4">
                        Ingrese la raíz $x_r$ encontrada por cualquiera de los métodos para evaluar $f(x_r)$ y verificar qué tan cerca está de cero.
                    </p>
                    <div class="flex space-x-4">
                        <div class="flex-grow">
                            <label for="checkRootValue" class="block text-sm font-medium text-gray-700 mb-1">Raíz (x_r) a Comprobar</label>
                            <input type="number" id="checkRootValue" step="any"
                                   class="w-full p-3 input-box rounded-lg text-gray-900"
                                   placeholder="Ingrese la raíz obtenida">
                        </div>
                        <button class="flex-shrink-0 button-primary text-white p-3 rounded-lg font-semibold shadow-md hover:shadow-lg transition-shadow self-end" onclick="checkRoot()">
                            Comprobar f(x_r)
                        </button>
                    </div>
                </div>
                <div id="exacta-result" class="mt-6"></div>
            </div>

        </div>

    </div>

    <script>
        // =================================================================
        // UTILIDADES Y LÓGICA MATEMÁTICA
        // =================================================================

        /**
         * Función que crea una función JavaScript a partir de la ecuación de entrada.
         * Asegura la disponibilidad de constantes y funciones Math.
         * @param {string} equation - La ecuación de la función f(x).
         * @returns {Function} - La función f(x) lista para ser evaluada.
         */
        function createFunction(equation) {
            // Asegura que las funciones Math sean accesibles y convierte ** para potencia
            const funcBody = equation
                .replace(/e\*\*/g, 'Math.exp') // Maneja Math.exp(x) si el usuario usa e**
                .replace(/exp/g, 'Math.exp')
                .replace(/sin/g, 'Math.sin')
                .replace(/cos/g, 'Math.cos')
                .replace(/tan/g, 'Math.tan')
                .replace(/log/g, 'Math.log') // log natural
                .replace(/sqrt/g, 'Math.sqrt');

            try {
                // Crea y retorna la función. 'x' es la variable independiente.
                return new Function('x', `
                    const E = Math.E;
                    const PI = Math.PI;
                    // Intentar evaluar la expresión con la variable x
                    return ${funcBody};
                `);
            } catch (e) {
                displayError("Error de Sintaxis en la Función: Verifique la entrada.", 'biseccion');
                return null;
            }
        }

        /**
         * Calcula la derivada numérica de f(x) en el punto x.
         * @param {Function} f - La función a derivar.
         * @param {number} x - El punto donde se calcula la derivada.
         * @param {number} h - El paso pequeño para la diferencia central.
         * @returns {number} - El valor de f'(x).
         */
        function numericalDerivative(f, x, h) {
            // Uso de la fórmula de diferencia central para mayor precisión:
            // f'(x) ≈ (f(x + h) - f(x - h)) / (2h)
            const fxPlusH = f(x + h);
            const fxMinusH = f(x - h);

            if (isNaN(fxPlusH) || isNaN(fxMinusH)) {
                return NaN;
            }

            return (fxPlusH - fxMinusH) / (2 * h);
        }

        // =================================================================
        // MÉTODOS NUMÉRICOS
        // =================================================================

        /**
         * Método de Bisección
         * @param {Function} f - La función f(x).
         * @param {number} a - Límite inferior.
         * @param {number} b - Límite superior.
         * @param {number} tol - Tolerancia.
         * @param {number} maxIter - Máximo de iteraciones.
         * @returns {object} - {root: number, iterations: number, history: array}
         */
        function solveBisection(f, a, b, tol, maxIter) {
            const fa = f(a);
            const fb = f(b);

            if (isNaN(fa) || isNaN(fb)) {
                return { error: true, message: "Error: La función no es válida en los límites iniciales (a o b)." };
            }

            if (fa * fb >= 0) {
                return { error: true, message: `Error: f(a) y f(b) deben tener signos opuestos. f(${a}) = ${fa.toFixed(6)}, f(${b}) = ${fb.toFixed(6)}` };
            }

            let iterations = 0;
            let history = [];
            let c, fc, error;

            while (iterations < maxIter) {
                c = (a + b) / 2;
                fc = f(c);
                error = Math.abs(b - a) / 2;

                history.push({ i: iterations + 1, a: a, b: b, c: c, fc: fc, error: error });

                if (fc === 0 || error < tol) {
                    return { root: c, iterations: iterations + 1, history: history };
                }

                if (fa * fc < 0) {
                    b = c;
                } else {
                    a = c;
                }
                iterations++;
            }

            return { error: true, message: `No se encontró la raíz en ${maxIter} iteraciones. Última estimación: ${c.toFixed(6)}` };
        }

        /**
         * Método de Newton-Raphson
         * @param {Function} f - La función f(x).
         * @param {Function} df - La función derivada f'(x) (numérica).
         * @param {number} x0 - Estimación inicial.
         * @param {number} tol - Tolerancia.
         * @param {number} maxIter - Máximo de iteraciones.
         * @returns {object} - {root: number, iterations: number, history: array}
         */
        function solveNewton(f, df, x0, tol, maxIter) {
            let x_curr = x0;
            let iterations = 0;
            let history = [];
            let fx, dfx, x_next, error;

            while (iterations < maxIter) {
                fx = f(x_curr);
                dfx = df(x_curr);

                if (isNaN(fx) || isNaN(dfx)) {
                    return { error: true, message: `Error: La función o su derivada no es válida en x = ${x_curr.toFixed(6)}.` };
                }

                if (Math.abs(fx) < tol) {
                    return { root: x_curr, iterations: iterations, history: history };
                }

                if (Math.abs(dfx) < 1e-10) { // Cuidado con la división por cero
                    return { error: true, message: `Error: Derivada muy cercana a cero en x = ${x_curr.toFixed(6)}.` };
                }

                x_next = x_curr - (fx / dfx);
                error = Math.abs(x_next - x_curr);

                history.push({ i: iterations + 1, x: x_curr, fx: fx, dfx: dfx, x_next: x_next, error: error });

                if (error < tol) {
                    return { root: x_next, iterations: iterations + 1, history: history };
                }

                x_curr = x_next;
                iterations++;
            }

            return { error: true, message: `No se encontró la raíz en ${maxIter} iteraciones. Última estimación: ${x_curr.toFixed(6)}` };
        }

        /**
         * Método de la Secante
         * @param {Function} f - La función f(x).
         * @param {number} x0 - Primera estimación inicial.
         * @param {number} x1 - Segunda estimación inicial.
         * @param {number} tol - Tolerancia.
         * @param {number} maxIter - Máximo de iteraciones.
         * @returns {object} - {root: number, iterations: number, history: array}
         */
        function solveSecant(f, x0, x1, tol, maxIter) {
            let x_prev = x0;
            let x_curr = x1;
            let iterations = 0;
            let history = [];
            let fx_prev, fx_curr, x_next, error;

            fx_prev = f(x_prev);
            if (isNaN(fx_prev)) {
                return { error: true, message: `Error: La función no es válida en x0 = ${x0}.` };
            }

            while (iterations < maxIter) {
                fx_curr = f(x_curr);

                if (isNaN(fx_curr)) {
                    return { error: true, message: `Error: La función no es válida en x = ${x_curr.toFixed(6)}.` };
                }

                if (Math.abs(fx_curr) < tol) {
                    return { root: x_curr, iterations: iterations, history: history };
                }

                if (x_curr - x_prev === 0) {
                    return { error: true, message: "Error: División por cero (x_curr - x_prev = 0)." };
                }

                // Fórmula de la Secante: x_next = x_curr - f(x_curr) * (x_curr - x_prev) / (f(x_curr) - f(x_prev))
                x_next = x_curr - fx_curr * (x_curr - x_prev) / (fx_curr - fx_prev);
                error = Math.abs(x_next - x_curr);

                history.push({ i: iterations + 1, x_prev: x_prev, x_curr: x_curr, fx_curr: fx_curr, x_next: x_next, error: error });

                if (error < tol) {
                    return { root: x_next, iterations: iterations + 1, history: history };
                }

                x_prev = x_curr;
                fx_prev = fx_curr;
                x_curr = x_next;
                iterations++;
            }

            return { error: true, message: `No se encontró la raíz en ${maxIter} iteraciones. Última estimación: ${x_curr.toFixed(6)}` };
        }

        // =================================================================
        // LÓGICA DE INTERFAZ DE USUARIO Y EJECUCIÓN
        // =================================================================

        let currentTab = 'biseccion';

        /**
         * Cambia la pestaña de método activa.
         * @param {string} tabId - ID del método a activar.
         */
        function switchTab(tabId) {
            currentTab = tabId;
            // Oculta todos los contenidos
            document.querySelectorAll('.method-content').forEach(el => el.classList.add('hidden'));
            // Desactiva todos los botones de pestaña
            document.querySelectorAll('[id^="tab-"]').forEach(el => el.classList.remove('tab-active'));

            // Muestra el contenido y activa el botón de la pestaña seleccionada
            document.getElementById(`content-${tabId}`).classList.remove('hidden');
            document.getElementById(`tab-${tabId}`).classList.add('tab-active');
            
            // Limpia los resultados cuando se cambia de pestaña
            document.getElementById('biseccion-result').innerHTML = '';
            document.getElementById('newton-result').innerHTML = '';
            document.getElementById('secante-result').innerHTML = '';
            document.getElementById('exacta-result').innerHTML = '';
        }

        /**
         * Maneja la ejecución del método de solución seleccionado.
         * @param {string} method - El método a ejecutar ('biseccion', 'newton', 'secante').
         */
        function runSolver(method) {
            const equation = document.getElementById('equation').value.trim();
            const tol = parseFloat(document.getElementById('tolerance').value);
            const maxIter = parseInt(document.getElementById('maxIterations').value);
            const a = parseFloat(document.getElementById('aValue').value);
            const b = parseFloat(document.getElementById('bValue').value);
            const x0 = parseFloat(document.getElementById('x0Value').value);
            const h = parseFloat(document.getElementById('hValue').value);

            const resultContainerId = `${method}-result`;
            const f = createFunction(equation);

            if (!f || isNaN(tol) || isNaN(maxIter) || tol <= 0 || maxIter <= 0) {
                return displayError("Revise los parámetros de entrada: Ecuación, Tolerancia o Máx. Iteraciones no son válidos.", resultContainerId);
            }

            let result;

            switch (method) {
                case 'biseccion':
                    if (isNaN(a) || isNaN(b)) {
                        return displayError("Los límites 'a' y 'b' son requeridos para el método de Bisección.", resultContainerId);
                    }
                    result = solveBisection(f, a, b, tol, maxIter);
                    break;
                case 'newton':
                    if (isNaN(x0) || isNaN(h) || h <= 0) {
                        return displayError("La estimación inicial 'x0' y 'h' para la derivada son requeridos para Newton.", resultContainerId);
                    }
                    // Definir la derivada numérica con el 'h' actual
                    const df = (x) => numericalDerivative(f, x, h);
                    result = solveNewton(f, df, x0, tol, maxIter);
                    break;
                case 'secante':
                    if (isNaN(x0) || isNaN(b)) { // Usamos b como x1
                        return displayError("Las estimaciones iniciales 'x0' y 'x1' (Límite Superior) son requeridas para Secante.", resultContainerId);
                    }
                    result = solveSecant(f, x0, b, tol, maxIter);
                    break;
                default:
                    return;
            }

            renderResult(result, resultContainerId, method);
        }
        
        /**
         * Función para comprobar la raíz ingresada en la pestaña "Exacta".
         */
        function checkRoot() {
            const equation = document.getElementById('equation').value.trim();
            const x = parseFloat(document.getElementById('checkRootValue').value);
            const resultContainerId = 'exacta-result';
            const f = createFunction(equation);

            if (!f || isNaN(x)) {
                return displayError("Revise la ecuación y asegúrese de ingresar un valor numérico para la raíz.", resultContainerId);
            }

            const fx = f(x);

            if (isNaN(fx)) {
                return displayError(`La función f(x) no pudo ser evaluada en x=${x}. Revise la sintaxis de la ecuación.`, resultContainerId);
            }

            const html = `
                <div class="p-4 rounded-lg shadow-md bg-green-50 border border-green-200">
                    <p class="font-semibold text-lg text-green-700 mb-2">Resultado de la Comprobación</p>
                    <p class="text-gray-800">Evaluando la función en <span class="font-mono bg-gray-200 p-1 rounded">x = ${x.toPrecision(10)}</span>:</p>
                    <p class="text-xl font-bold text-green-900 mt-2">f(x) ≈ ${fx.toExponential(6)}</p>
                    <p class="mt-2 text-sm text-gray-600">
                        Cuanto más cerca de cero esté este valor, más precisa es la raíz encontrada.
                    </p>
                </div>
            `;
            document.getElementById(resultContainerId).innerHTML = html;
        }


        /**
         * Muestra un mensaje de error en el contenedor de resultados.
         */
        function displayError(message, containerId) {
            const html = `
                <div class="p-4 rounded-lg bg-red-100 text-red-800 font-medium" role="alert">
                    <span class="font-bold">Error:</span> ${message}
                </div>
            `;
            document.getElementById(containerId).innerHTML = html;
        }

        /**
         * Renderiza los resultados de la solución y la tabla de historial.
         */
        function renderResult(result, containerId, method) {
            const container = document.getElementById(containerId);
            
            if (result.error) {
                return displayError(result.message, containerId);
            }

            const formatter = (value) => value.toPrecision(10); // Formato para el historial
            
            // 1. Cabecera del resultado
            let resultHTML = `
                <div class="mb-6 p-4 rounded-lg shadow-lg bg-blue-50 border border-blue-200">
                    <h3 class="text-xl font-bold text-blue-800 mb-2">¡Raíz Encontrada!</h3>
                    <p class="text-gray-700"><strong>Raíz Aproximada (x):</strong> <span class="text-2xl font-mono text-blue-900">${result.root.toPrecision(15)}</span></p>
                    <p class="text-gray-700"><strong>Iteraciones Requeridas:</strong> ${result.iterations}</p>
                </div>
            `;

            // 2. Tabla de historial
            const headers = {
                biseccion: ['i', 'a', 'b', 'c', 'f(c)', 'Error'],
                newton: ['i', 'x_i', 'f(x_i)', 'f\'(x_i)', 'x_{i+1}', 'Error'],
                secante: ['i', 'x_{i-1}', 'x_i', 'f(x_i)', 'x_{i+1}', 'Error']
            };
            const currentHeaders = headers[method];

            let tableHTML = `
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Historial de Iteraciones</h3>
                <div class="overflow-x-auto rounded-lg border shadow-sm">
                    <table class="min-w-full divide-y divide-gray-200 result-table">
                        <thead class="bg-gray-50">
                            <tr>
                                ${currentHeaders.map(h => `<th scope="col" class="px-3 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">${h}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200 text-sm">
            `;

            result.history.forEach(row => {
                let rowValues;
                if (method === 'biseccion') {
                    rowValues = [row.i, row.a, row.b, row.c, row.fc, row.error];
                } else if (method === 'newton') {
                    rowValues = [row.i, row.x, row.fx, row.dfx, row.x_next, row.error];
                } else if (method === 'secante') {
                    rowValues = [row.i, row.x_prev, row.x_curr, row.fx_curr, row.x_next, row.error];
                }

                tableHTML += `
                    <tr>
                        ${rowValues.map(val => `<td class="px-3 py-2 whitespace-nowrap">${typeof val === 'number' ? formatter(val) : val}</td>`).join('')}
                    </tr>
                `;
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = resultHTML + tableHTML;
            
            // Auto-rellenar la pestaña de comprobación con el resultado
            document.getElementById('checkRootValue').value = result.root.toPrecision(15);
        }

        // Inicializar la vista en la primera pestaña al cargar
        document.addEventListener('DOMContentLoaded', () => {
            switchTab('biseccion');
        });
    </script>
</body>
</html>